<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- Primary Meta Tags -->
  <title>
    Free Snapchat Memories Downloader - Save Before Snapchat Charges | No
    Upload Required
  </title>
  <meta name="title" content="Free Snapchat Memories Downloader - Save Before Snapchat Charges | No Upload Required" />
  <meta name="description"
    content="100% free tool to download all your Snapchat memories with metadata before Snapchat starts charging. No upload required - runs entirely in your browser. Free alternative to paid services. Preserve your photos, videos, and GPS data safely." />
  <meta name="keywords"
    content="snapchat memories downloader, free snapchat backup, save snapchat memories, snapchat charging for storage, free alternative, free exportsnaps, download snapchat photos, snapchat metadata, private snapchat downloader, local snapchat backup, snapchat memories free, browser-based snapchat downloader, no upload snapchat, preserve snapchat memories" />
  <meta name="author" content="andrefecto" />
  <meta name="robots" content="index, follow" />

  <!-- Open Graph / Facebook -->
  <meta property="og:type" content="website" />
  <meta property="og:url" content="https://andrefecto.github.io/Snapchat-Memories-Downloader/" />
  <meta property="og:title" content="Free Snapchat Memories Downloader - Save Before Snapchat Charges" />
  <meta property="og:description"
    content="100% free tool to download all your Snapchat memories before they start charging. No upload required - completely private and runs in your browser. Free alternative to paid services." />
  <meta property="og:image" content="https://andrefecto.github.io/Snapchat-Memories-Downloader/og-image.png" />

  <!-- Twitter -->
  <meta property="twitter:card" content="summary_large_image" />
  <meta property="twitter:url" content="https://andrefecto.github.io/Snapchat-Memories-Downloader/" />
  <meta property="twitter:title" content="Free Snapchat Memories Downloader - Save Before Snapchat Charges" />
  <meta property="twitter:description"
    content="100% free tool to download all your Snapchat memories. No upload required - runs entirely in your browser. Save before Snapchat starts charging!" />
  <meta property="twitter:image" content="https://andrefecto.github.io/Snapchat-Memories-Downloader/og-image.png" />

  <!-- Canonical URL -->
  <link rel="canonical" href="https://andrefecto.github.io/Snapchat-Memories-Downloader/" />

  <!-- Structured Data / JSON-LD -->
  <script type="application/ld+json">
      {
        "@context": "https://schema.org",
        "@type": "SoftwareApplication",
        "name": "Snapchat Memories Downloader",
        "applicationCategory": "UtilityApplication",
        "operatingSystem": "Web Browser",
        "offers": {
          "@type": "Offer",
          "price": "0",
          "priceCurrency": "USD"
        },
        "description": "Free tool to download all your Snapchat memories with metadata. No upload required - runs entirely in your browser. Save your photos and videos before Snapchat starts charging for storage.",
        "author": {
          "@type": "Person",
          "name": "andrefecto",
          "url": "https://github.com/andrefecto"
        },
        "aggregateRating": {
          "@type": "AggregateRating",
          "ratingValue": "5",
          "ratingCount": "1"
        }
      }
    </script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/piexifjs@1.0.6/piexif.min.js"></script>
  <!-- FFmpeg.wasm for video processing -->
  <script src="ffmpeg/ffmpeg.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
        Oxygen, Ubuntu, Cantarell, sans-serif;
      line-height: 1.6;
      color: #333;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }

    .container {
      max-width: 800px;
      margin: 0 auto;
      background: white;
      border-radius: 12px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      padding: 40px;
    }

    h1 {
      color: #667eea;
      margin-bottom: 10px;
      font-size: 2.5em;
    }

    .subtitle {
      color: #666;
      margin-bottom: 30px;
      font-size: 1.1em;
    }

    .warning {
      background: #fff3cd;
      border-left: 4px solid #ffc107;
      padding: 15px;
      margin-bottom: 25px;
      border-radius: 4px;
    }

    .warning strong {
      color: #856404;
    }

    .upload-section {
      background: #f8f9fa;
      border: 2px dashed #dee2e6;
      border-radius: 8px;
      padding: 40px;
      text-align: center;
      margin-bottom: 25px;
      transition: all 0.3s;
    }

    .upload-section:hover {
      border-color: #667eea;
      background: #f0f2ff;
    }

    .upload-section.dragover {
      border-color: #667eea;
      background: #e8eaff;
    }

    input[type="file"] {
      display: none;
    }

    .btn {
      background: #667eea;
      color: white;
      padding: 12px 30px;
      border: none;
      border-radius: 6px;
      font-size: 16px;
      cursor: pointer;
      transition: all 0.3s;
      font-weight: 600;
    }

    .btn:hover {
      background: #5568d3;
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
    }

    .btn:disabled {
      background: #ccc;
      cursor: not-allowed;
      transform: none;
    }

    .progress-container {
      display: none;
      margin-top: 25px;
    }

    .progress-bar {
      background: #e9ecef;
      border-radius: 10px;
      height: 30px;
      overflow: hidden;
      margin-bottom: 15px;
    }

    .progress-fill {
      background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
      height: 100%;
      width: 0%;
      transition: width 0.3s;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: 600;
      font-size: 14px;
    }

    .status {
      color: #666;
      font-size: 14px;
      margin-bottom: 10px;
    }

    .log {
      background: #f8f9fa;
      border: 1px solid #dee2e6;
      border-radius: 6px;
      padding: 15px;
      max-height: 300px;
      overflow-y: auto;
      font-family: "Courier New", monospace;
      font-size: 13px;
      line-height: 1.4;
    }

    .log-entry {
      margin-bottom: 5px;
    }

    .log-entry.success {
      color: #28a745;
    }

    .log-entry.error {
      color: #dc3545;
    }

    .log-entry.info {
      color: #666;
    }

    .log-entry.warning {
      color: #ffc107;
    }

    .log-entry.ffmpeg {
      color: #6c757d;
      font-size: 12px;
    }

    .log-tabs {
      display: flex;
      gap: 5px;
      margin-bottom: 10px;
      border-bottom: 2px solid #dee2e6;
    }

    .log-tab {
      padding: 8px 16px;
      background: #f8f9fa;
      border: none;
      border-bottom: 3px solid transparent;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      color: #666;
      transition: all 0.2s;
    }

    .log-tab:hover {
      background: #e9ecef;
      color: #333;
    }

    .log-tab.active {
      background: white;
      color: #667eea;
      border-bottom-color: #667eea;
    }

    .log-content {
      display: none;
    }

    .log-content.active {
      display: block;
    }

    .features {
      margin-top: 40px;
      padding-top: 30px;
      border-top: 2px solid #e9ecef;
    }

    .features h2 {
      color: #667eea;
      margin-bottom: 15px;
    }

    .features ul {
      list-style: none;
      padding-left: 0;
    }

    .features li {
      padding: 8px 0;
      padding-left: 25px;
      position: relative;
    }

    .features li:before {
      content: "‚úì";
      position: absolute;
      left: 0;
      color: #28a745;
      font-weight: bold;
    }

    .footer-links {
      text-align: center;
      margin-top: 30px;
      padding-top: 20px;
      border-top: 1px solid #e9ecef;
    }

    .footer-links a {
      color: #667eea;
      text-decoration: none;
      font-weight: 600;
      margin: 0 10px;
    }

    .footer-links a:hover {
      text-decoration: underline;
    }

    .coffee-btn {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      background: #ffdd00;
      color: #000;
      padding: 10px 20px;
      border-radius: 8px;
      text-decoration: none;
      font-weight: 600;
      margin-top: 15px;
      transition: all 0.3s;
      box-shadow: 0 2px 8px rgba(255, 221, 0, 0.3);
    }

    .coffee-btn:hover {
      background: #ffed4e;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(255, 221, 0, 0.4);
      text-decoration: none;
    }

    .github-badge {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      background: #24292e;
      color: white;
      padding: 10px 20px;
      border-radius: 8px;
      text-decoration: none;
      font-weight: 600;
      transition: all 0.3s;
      box-shadow: 0 2px 8px rgba(36, 41, 46, 0.3);
    }

    .github-badge:hover {
      background: #2f363d;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(36, 41, 46, 0.4);
      text-decoration: none;
      color: white;
    }

    .info-box {
      background: #e7f3ff;
      border-left: 4px solid #667eea;
      padding: 20px;
      margin-bottom: 25px;
      border-radius: 4px;
    }

    .info-box h3 {
      margin-top: 0;
      color: #667eea;
    }

    .info-box ol {
      margin: 10px 0;
      padding-left: 25px;
    }

    .info-box li {
      margin: 8px 0;
    }

    .info-box a {
      color: #667eea;
      font-weight: 600;
    }
  </style>
</head>

<body>
  <div class="container">
    <h1>Free Snapchat Memories Downloader</h1>
    <p class="subtitle">
      Save ALL your Snapchat memories before they start charging for storage -
      100% FREE & Private
    </p>

    <div class="warning" style="background: #fff3cd; border-color: #ffc107">
      <strong>‚ö†Ô∏è Snapchat is Charging for Storage Soon!</strong> Download your
      memories now for FREE. Don't pay for paid services - this tool is 100%
      free and safer because your data never leaves your browser.
    </div>

    <div class="warning">
      <strong>üîí Privacy First:</strong> Your data never leaves your browser.
      Everything is processed locally on your device. No upload required -
      completely offline processing.
    </div>

    <div class="info-box">
      <h3>üì• First Time? Get Your Snapchat Data</h3>
      <p>
        Before using this tool, you need to download your data from Snapchat:
      </p>
      <ol>
        <li>
          <strong>Login</strong> to
          <a href="https://accounts.snapchat.com/" target="_blank">Snapchat's website</a>
        </li>
        <li>
          Click the <strong>menu</strong> in the top left corner
          <ul style="list-style: none; padding-left: 15px; margin: 5px 0">
            <li>Mobile: Tap "Accounts"</li>
            <li>Desktop: Click "Account Settings"</li>
          </ul>
        </li>
        <li>Click <strong>"My Data"</strong></li>
        <li>
          Select the data you want:
          <ul style="list-style: none; padding-left: 15px; margin: 5px 0">
            <li>‚úÖ <strong>Memories</strong> (required for this tool)</li>
            <li>‚úÖ <strong>Chat Media</strong> (optional - now separate)</li>
            <li>
              ‚úÖ <strong>Shared Stories</strong> (optional - now separate)
            </li>
          </ul>
        </li>
        <li>Click <strong>"Submit Request"</strong></li>
        <li>Wait for Snapchat to email you (24-48 hours)</li>
        <li>Download the ZIP and extract it</li>
        <li>
          Find <code>memories_history.html</code> in the
          <code>html/</code> folder
        </li>
      </ol>
      <p style="font-size: 14px; margin-top: 15px">
        <a href="https://www.reddit.com/r/techsupport/comments/18mkfvv/is_there_a_way_of_exporting_all_snapchat/"
          target="_blank">More info on Reddit</a>
      </p>
    </div>

    <div class="upload-section" id="uploadSection">
      <svg width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="#667eea" stroke-width="2"
        style="margin-bottom: 15px">
        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
        <polyline points="17 8 12 3 7 8"></polyline>
        <line x1="12" y1="3" x2="12" y2="15"></line>
      </svg>
      <h3 style="margin-bottom: 10px">Upload memories_history.html</h3>
      <p style="color: #666; margin-bottom: 20px">
        Drag and drop or click to browse
      </p>
      <input type="file" id="fileInput" accept=".html" />
      <label for="fileInput" class="btn">Choose HTML File</label>
      <p id="fileName" style="margin-top: 15px; color: #667eea; font-weight: 600"></p>

      <div style="
            margin-top: 25px;
            padding-top: 20px;
            border-top: 1px solid #dee2e6;
          ">
        <h4 style="margin-bottom: 10px; font-size: 16px">
          Resume/Retry (Optional)
        </h4>
        <p style="color: #666; margin-bottom: 15px; font-size: 14px">
          Upload metadata.json to resume or retry failed downloads
        </p>
        <input type="file" id="metadataInput" accept=".json" />
        <label for="metadataInput" class="btn" style="background: #28a745">Choose metadata.json</label>
        <p id="metadataFileName" style="margin-top: 10px; color: #28a745; font-weight: 600"></p>
      </div>

      <div style="
            margin-top: 25px;
            padding-top: 20px;
            border-top: 1px solid #dee2e6;
          ">
        <label style="
              display: flex;
              align-items: center;
              gap: 10px;
              cursor: pointer;
              font-size: 16px;
            ">
          <input type="checkbox" id="mergeOverlaysCheckbox" style="width: 18px; height: 18px; cursor: pointer" />
          <span><strong>Merge overlays</strong> (images and videos)</span>
        </label>
        <p style="
              color: #666;
              margin-top: 10px;
              font-size: 14px;
              margin-left: 28px;
            ">
          Combine -main and -overlay files into a single file. Video merging
          uses FFmpeg.wasm (may take 1-5 minutes per video).
        </p>
      </div>

      <div style="
            margin-top: 25px;
            padding-top: 20px;
            border-top: 1px solid #dee2e6;
          ">
        <div style="margin-bottom: 15px">
          <label style="
                display: flex;
                align-items: center;
                gap: 10px;
                cursor: pointer;
                font-size: 16px;
              ">
            <input type="checkbox" id="videosOnlyCheckbox" style="width: 18px; height: 18px; cursor: pointer" />
            <span><strong>Videos only</strong> (skip pictures)</span>
          </label>
          <p style="
                color: #666;
                margin-top: 10px;
                font-size: 14px;
                margin-left: 28px;
              ">
            Only download and process videos. Useful for re-processing videos
            with overlay merging.
          </p>
        </div>
        <div>
          <label style="
                display: flex;
                align-items: center;
                gap: 10px;
                cursor: pointer;
                font-size: 16px;
              ">
            <input type="checkbox" id="picturesOnlyCheckbox" style="width: 18px; height: 18px; cursor: pointer" />
            <span><strong>Pictures only</strong> (skip videos)</span>
          </label>
          <p style="
                color: #666;
                margin-top: 10px;
                font-size: 14px;
                margin-left: 28px;
              ">
            Only download and process pictures. Useful for re-processing
            images with overlay merging.
          </p>
        </div>
      </div>

      <div style="
            margin-top: 25px;
            padding-top: 20px;
            border-top: 1px solid #dee2e6;
          ">
        <label style="display: block; margin-bottom: 10px; font-size: 16px"><strong>Batch Size</strong></label>
        <select id="batchSizeSelect" style="
              padding: 8px;
              border: 2px solid #667eea;
              border-radius: 4px;
              font-size: 14px;
              width: 200px;
            ">
          <option value="10">10 files per batch</option>
          <option value="20">20 files per batch</option>
          <option value="50" selected>50 files per batch</option>
          <option value="100">100 files per batch</option>
          <option value="200">200 files per batch</option>
          <option value="0">All in one ZIP</option>
        </select>
        <p style="color: #666; margin-top: 10px; font-size: 14px">
          Downloads will be split into multiple ZIP files. Videos with overlays are processed individually to prevent memory issues.
        </p>
      </div>

      <div style="
            margin-top: 25px;
            padding-top: 20px;
            border-top: 1px solid #dee2e6;
          ">
        <label style="display: block; margin-bottom: 10px; font-size: 16px"><strong>Video Memory Management</strong></label>
        <select id="ffmpegResetIntervalSelect" style="
              padding: 8px;
              border: 2px solid #667eea;
              border-radius: 4px;
              font-size: 14px;
              width: 250px;
            ">
          <option value="3">Reset every 3 videos (safest)</option>
          <option value="5" selected>Reset every 5 videos (recommended)</option>
          <option value="10">Reset every 10 videos (faster)</option>
          <option value="999">Never reset (risky)</option>
        </select>
        <p style="color: #666; margin-top: 10px; font-size: 14px">
          Recreates the video processor to prevent memory buildup. Lower values are safer but slightly slower.
        </p>
      </div>

      <div style="margin-top: 30px; text-align: center">
        <button id="startButton" style="
              display: none;
              background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
              color: white;
              border: none;
              padding: 15px 40px;
              font-size: 18px;
              font-weight: bold;
              border-radius: 8px;
              cursor: pointer;
              box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
              transition: transform 0.2s, box-shadow 0.2s;
            "
          onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(102, 126, 234, 0.6)'"
          onmouseout="this.style.transform=''; this.style.boxShadow='0 4px 15px rgba(102, 126, 234, 0.4)'"
          onclick="handleStartDownload()">
          üöÄ Start Download
        </button>
      </div>
    </div>

    <div class="progress-container" id="progressContainer">
      <div class="status" id="status">Preparing download...</div>
      <div class="progress-bar">
        <div class="progress-fill" id="progressFill">0%</div>
      </div>
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
        <div style="color: #666; font-size: 14px; font-weight: 600;">Activity Logs</div>
        <button id="copyLogsBtn" class="btn" style="padding: 6px 15px; font-size: 13px;" onclick="copyLogsToClipboard()">
          üìã Copy Logs
        </button>
      </div>

      <div class="log-tabs">
        <button class="log-tab active" onclick="switchLogTab('main')">Main Activity</button>
        <button class="log-tab" onclick="switchLogTab('ffmpeg')">FFmpeg Details</button>
      </div>

      <div id="log-main" class="log-content active">
        <div class="log" id="log"></div>
      </div>

      <div id="log-ffmpeg" class="log-content">
        <div class="log" id="logFFmpeg"></div>
      </div>
    </div>

    <div class="features">
      <h2>Why Use This Free Tool?</h2>
      <ul>
        <li>
          <strong>100% FREE</strong> - Don't pay for paid services that charge
          money
        </li>
        <li>
          <strong>Save Before Snapchat Charges</strong> - Download now before
          storage fees kick in
        </li>
        <li>
          <strong>Completely Private</strong> - No upload required, runs in
          your browser offline
        </li>
        <li>
          <strong>Preserves Everything</strong> - GPS coordinates, dates, and
          all metadata intact
        </li>
        <li>
          <strong>Handles Overlays</strong> - Extracts both main and overlay
          files from edited snaps
        </li>
        <li>
          <strong>Optional Overlay Merging</strong> - Combine overlays with
          main images for cleaner organization
        </li>
        <li>
          <strong>Resume Support</strong> - Pick up where you left off if
          interrupted
        </li>
        <li>
          <strong>Safe & Secure</strong> - Your memories never leave your
          computer
        </li>
        <li>
          <strong>One-Click Download</strong> - Get everything in a convenient
          ZIP file
        </li>
      </ul>
    </div>

    <div class="features">
      <h2>Frequently Asked Questions</h2>
      <div style="text-align: left; padding-left: 20px">
        <h3 style="margin-top: 20px; color: #667eea">Is this really free?</h3>
        <p>
          Yes! 100% free, forever. No hidden costs, no premium features. We
          built this to help people save their memories before Snapchat starts
          charging.
        </p>

        <h3 style="margin-top: 20px; color: #667eea">
          Is it safe? Do you upload my photos?
        </h3>
        <p>
          Completely safe. Your photos and videos never leave your computer.
          Everything runs in your browser - no server uploads, no cloud
          processing. Unlike paid services, your data stays 100% private.
        </p>

        <h3 style="margin-top: 20px; color: #667eea">
          How is this different from paid services?
        </h3>
        <p>
          Other services charge money and require you to upload your data to
          their servers. This tool is FREE and runs entirely on your computer
          - your data never leaves your device.
        </p>

        <h3 style="margin-top: 20px; color: #667eea">
          Will this work if Snapchat starts charging?
        </h3>
        <p>
          Yes! This downloads your memories from Snapchat's data export, which
          will always be available regardless of storage fees. Download now to
          avoid future charges.
        </p>

        <h3 style="margin-top: 20px; color: #667eea">
          Does it preserve GPS location data?
        </h3>
        <p>
          Yes! All metadata is preserved including GPS coordinates, dates, and
          media types. Perfect for backing up your memories with all their
          original information.
        </p>

        <h3 style="margin-top: 20px; color: #667eea">
          What if the download fails or gets interrupted?
        </h3>
        <p>
          No problem! Simply upload your metadata.json file (included in the
          ZIP) and it will resume from where you left off. All progress is
          saved.
        </p>

        <h3 style="margin-top: 20px; color: #667eea">
          Can I download Chat Media and Shared Stories too?
        </h3>
        <p>
          Yes! When requesting your data from Snapchat, select "Chat Media"
          and "Shared Stories" in addition to "Memories". This tool works with
          all of them.
        </p>

        <h3 style="margin-top: 20px; color: #667eea">
          Videos are still coming out black with audio - what should I do?
        </h3>
        <p>
          <strong>Recent Fix:</strong> The tool now automatically converts WebP/JPEG/etc overlays to PNG before processing, which fixes most black screen issues.
        </p>
        <p style="margin-top: 10px;">
          <strong>If you still have issues:</strong>
        </p>
        <ol style="margin-left: 20px; margin-top: 5px;">
          <li>Hard refresh the page (Ctrl+F5 or Cmd+Shift+R)</li>
          <li>Check the "FFmpeg Details" tab for errors</li>
          <li>Try a different browser (Chrome/Edge recommended over Firefox)</li>
        </ol>
        <p style="margin-top: 10px;">
          <strong>Still failing? Use the Python script:</strong>
        </p>
        <ol style="margin-left: 20px; margin-top: 5px;">
          <li>Download: <code>git clone https://github.com/andrefecto/Snapchat-Memories-Downloader.git</code></li>
          <li>Install FFmpeg (<a href="https://ffmpeg.org/download.html" target="_blank" style="color: #667eea;">ffmpeg.org</a>)</li>
          <li>Run: <code>python download_memories.py</code></li>
        </ol>
        <p style="margin-top: 10px;">
          The Python script uses native FFmpeg (not WASM) and is 100% reliable on Windows, Mac, and Linux.
        </p>

        <h3 style="margin-top: 20px; color: #667eea">
          How does individual video processing work?
        </h3>
        <p>
          To ensure <strong>zero memory accumulation</strong>, the tool uses a smart download strategy:
        </p>
        <ul style="margin-left: 20px; margin-top: 5px;">
          <li><strong>Images:</strong> Processed normally and accumulate in a ZIP</li>
          <li><strong>Videos with overlays:</strong> When encountered:
            <ol style="margin-left: 20px; margin-top: 5px;">
              <li>Current batch is downloaded immediately</li>
              <li>Video is merged in isolation</li>
              <li>Video gets its own dedicated ZIP file</li>
              <li>Processing continues with next items</li>
            </ol>
          </li>
          <li><strong>Result:</strong> Merged videos <strong>never</strong> accumulate in memory!</li>
        </ul>
        <p style="margin-top: 10px;">
          This means you can process 100+ items safely - you'll just get multiple ZIP files (images + individual videos).
        </p>

        <h3 style="margin-top: 20px; color: #667eea">
          How do I report issues or bugs?
        </h3>
        <p>
          If you encounter problems, please help us fix them by reporting the issue:
        </p>
        <ol style="margin-left: 20px; margin-top: 5px;">
          <li>Click the <strong>"üìã Copy Logs"</strong> button (copies both Main Activity and FFmpeg Details tabs)</li>
          <li>Go to the <a href="https://github.com/andrefecto/Snapchat-Memories-Downloader/issues" target="_blank" style="color: #667eea; font-weight: 600;">GitHub Issues page</a></li>
          <li>Create a new issue describing the problem</li>
          <li>Paste the copied logs into the issue</li>
          <li>Include browser type (Chrome/Firefox/Edge) and your device specs</li>
        </ol>
        <p style="margin-top: 10px;">
          The logs help identify exactly what went wrong and make it much easier to fix bugs quickly!
        </p>
      </div>
    </div>

    <div class="footer-links">
      <div style="margin-bottom: 15px">
        <a class="github-badge" href="https://github.com/andrefecto" target="_blank">
          <svg width="20" height="20" viewBox="0 0 16 16" fill="currentColor">
            <path
              d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z" />
          </svg>
          andrefecto
        </a>
      </div>
      <div style="margin-bottom: 15px">
        <a class="coffee-btn" href="https://buymeacoffee.com/andrefecto" target="_blank">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
            <path
              d="M20.216 6.415l-.132-.666c-.119-.598-.388-1.163-1.001-1.379-.197-.069-.42-.098-.57-.241-.152-.143-.196-.366-.231-.572-.065-.378-.125-.756-.192-1.133-.057-.325-.102-.69-.25-.987-.195-.4-.597-.634-.996-.788a5.723 5.723 0 00-.626-.194c-1-.263-2.05-.36-3.077-.416a25.834 25.834 0 00-3.7.062c-.915.083-1.88.184-2.75.5-.318.116-.646.256-.888.501-.297.302-.393.77-.177 1.146.154.267.415.456.692.58.36.162.737.284 1.123.366 1.075.238 2.189.331 3.287.37 1.218.05 2.437.01 3.65-.118.299-.033.598-.073.896-.119.352-.054.578-.513.474-.834-.124-.383-.457-.531-.834-.473-.466.074-.96.108-1.382.146-1.177.08-2.358.082-3.536.006a22.228 22.228 0 01-1.157-.107c-.086-.01-.18-.025-.258-.036-.243-.036-.484-.08-.724-.13-.111-.027-.111-.185 0-.212h.005c.277-.06.557-.108.838-.147h.002c.131-.009.263-.032.394-.048a25.076 25.076 0 013.426-.12c.674.019 1.347.067 2.017.144l.228.031c.267.04.533.088.798.145.392.085.895.113 1.07.542.055.137.08.288.111.431l.319 1.484a.237.237 0 01-.199.284h-.003c-.037.006-.075.01-.112.015a36.704 36.704 0 01-4.743.295 37.059 37.059 0 01-4.699-.304c-.14-.017-.293-.042-.417-.06-.326-.048-.649-.108-.973-.161-.393-.065-.768-.032-1.123.161-.29.16-.527.404-.675.701-.154.316-.199.66-.267 1-.069.34-.176.707-.135 1.056.087.753.613 1.365 1.37 1.502a39.69 39.69 0 0011.343.376.483.483 0 01.535.53l-.071.697-1.018 9.907c-.041.41-.047.832-.125 1.237-.122.637-.553 1.028-1.182 1.171-.577.131-1.165.2-1.756.205-.656.004-1.31-.025-1.966-.022-.699.004-1.556-.06-2.095-.58-.475-.458-.54-1.174-.605-1.793l-.731-7.013-.322-3.094c-.037-.351-.286-.695-.678-.678-.336.015-.718.3-.678.679l.228 2.185.949 9.112c.147 1.344 1.174 2.068 2.446 2.272.742.12 1.503.144 2.257.156.966.016 1.942.053 2.892-.122 1.408-.258 2.465-1.198 2.616-2.657.34-3.332.683-6.663 1.024-9.995l.215-2.087a.484.484 0 01.39-.426c.402-.078.787-.212 1.074-.518.455-.488.546-1.124.385-1.766zm-1.478.772c-.145.137-.363.201-.578.233-2.416.359-4.866.54-7.308.46-1.748-.06-3.477-.254-5.207-.498-.17-.024-.353-.055-.47-.18-.22-.236-.111-.71-.054-.995.052-.26.152-.609.463-.646.484-.057 1.046.148 1.526.22.577.088 1.156.159 1.737.212 2.48.226 5.002.19 7.472-.14.45-.06.899-.13 1.345-.21.399-.072.84-.206 1.08.206.166.281.188.657.162.974a.544.544 0 01-.169.364zm-6.159 3.9c-.862.37-1.84.788-3.109.788a5.884 5.884 0 01-1.569-.217l.877 9.004c.065.78.717 1.38 1.5 1.38 0 0 1.243.065 1.658.065.447 0 1.786-.065 1.786-.065.783 0 1.434-.6 1.499-1.38l.94-9.95a3.996 3.996 0 00-1.322-.238c-.826 0-1.491.284-2.26.613z" />
          </svg>
          Buy Me a Coffee
        </a>
      </div>
      <div style="color: #666; font-size: 14px">
        <a href="https://github.com/andrefecto/Snapchat-Memories-Downloader" target="_blank">
          View Source on GitHub
        </a>
        |
        <a href="https://github.com/andrefecto/Snapchat-Memories-Downloader#python-script" target="_blank">
          Python Script Version
        </a>
      </div>
    </div>
  </div>

  <script>
    // Global resource load error listener for debugging 404s
    window.addEventListener('error', function (e) {
      try {
        const src = e?.target?.src || e?.target?.href || null;
        if (src) console.error('Resource load failed:', src, e);
      } catch (err) {
        console.error('Error in resource load listener', err);
      }
    }, true);

    const fileInput = document.getElementById("fileInput");
    const metadataInput = document.getElementById("metadataInput");
    const uploadSection = document.getElementById("uploadSection");
    const fileName = document.getElementById("fileName");
    const metadataFileName = document.getElementById("metadataFileName");
    const startButton = document.getElementById("startButton");
    const progressContainer = document.getElementById("progressContainer");
    const progressFill = document.getElementById("progressFill");
    const status = document.getElementById("status");
    const log = document.getElementById("log");

    let memories = [];
    let existingMetadata = null;
    let currentIndex = 0;
    let zip = null;

    // FFmpeg.wasm for video overlay merging
    let ffmpegLoaded = false;
    let ffmpegInstance = null;
    let videosProcessedSinceReset = 0;
    let totalVideosProcessed = 0;

    /**
     * Terminate FFmpeg.wasm instance and release memory
     */
    async function terminateFFmpeg() {
      if (ffmpegInstance) {
        try {
          // Remove all event listeners
          ffmpegInstance.off('log');
          ffmpegInstance.off('progress');
          // Note: FFmpeg.wasm doesn't have a built-in terminate method
          // Setting to null allows garbage collection
          ffmpegInstance = null;
          ffmpegLoaded = false;
          videosProcessedSinceReset = 0;
          addLog('  FFmpeg instance terminated, memory released', 'info');
          // Give browser time to garbage collect
          await new Promise(resolve => setTimeout(resolve, 500));
        } catch (error) {
          console.warn('Error terminating FFmpeg:', error);
        }
      }
    }

    /**
     * Initialize FFmpeg.wasm instance
     * @param {boolean} forceReload - Force recreation even if already loaded
     */
    async function initFFmpeg(forceReload = false) {
      // Check if we need to reset due to memory concerns
      const resetInterval = parseInt(document.getElementById('ffmpegResetIntervalSelect')?.value || '5');

      if (forceReload || (videosProcessedSinceReset >= resetInterval && resetInterval < 999)) {
        if (ffmpegInstance) {
          addLog(`  Resetting FFmpeg after ${videosProcessedSinceReset} videos (prevents memory buildup)`, 'info');
          await terminateFFmpeg();
        }
      }

      if (ffmpegLoaded && ffmpegInstance) {
        return ffmpegInstance;
      }

      const { FFmpeg } = FFmpegWASM;
      ffmpegInstance = new FFmpeg();

      // Detect browser
      const isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
      const isChrome = navigator.userAgent.toLowerCase().indexOf('chrome') > -1;

      if (isFirefox) {
        addLog('  ‚ö†Ô∏è Firefox detected: Video merging may be unstable due to WASM limitations', 'warning');
        addLog('  Recommendation: Use Chrome or Edge for best results', 'warning');
        addLog('Firefox browser detected - known WASM/FFmpeg compatibility issues', 'warning', 'ffmpeg');
      }

      addLog('  Loading FFmpeg.wasm (this may take a few seconds)...', 'info');
      addLog('  üí° Check the "FFmpeg Details" tab for detailed conversion logs', 'info');
      addLog('Loading FFmpeg.wasm...', 'info', 'ffmpeg');

      await ffmpegInstance.load({
        coreURL: new URL('./ffmpeg/ffmpeg-core.js', window.location).href,
        wasmURL: new URL('./ffmpeg/ffmpeg-core.wasm', window.location).href,
        worker: false
      });

      // Log FFmpeg backend messages to FFmpeg tab
      ffmpegInstance.on('log', (m) => {
        try {
          const message = m && m.message ? m.message : JSON.stringify(m);
          addLog(message, 'ffmpeg', 'ffmpeg');
        } catch(e) {
          // Ignore logging errors
        }
      });

      ffmpegLoaded = true;
      videosProcessedSinceReset = 0;
      addLog('  FFmpeg loaded successfully', 'success');
      addLog('FFmpeg loaded and ready', 'success', 'ffmpeg');
      return ffmpegInstance;
    }

    /**
     * Check memory usage and warn if getting low (Chrome only)
     */
    function checkMemoryUsage() {
      try {
        if (performance.memory) {
          const usedMB = Math.round(performance.memory.usedJSHeapSize / 1024 / 1024);
          const limitMB = Math.round(performance.memory.jsHeapSizeLimit / 1024 / 1024);
          const percentUsed = Math.round((usedMB / limitMB) * 100);

          if (percentUsed > 80) {
            addLog(`  ‚ö†Ô∏è Memory usage high: ${usedMB}MB / ${limitMB}MB (${percentUsed}%)`, 'info');
            addLog(`  Recommendation: Close other tabs or reduce reset interval`, 'info');
          } else if (percentUsed > 60) {
            addLog(`  Memory usage: ${usedMB}MB / ${limitMB}MB (${percentUsed}%)`, 'info');
          }
          return { usedMB, limitMB, percentUsed };
        }
      } catch (e) {
        // performance.memory not available (Firefox, Safari)
      }
      return null;
    }

    /**
    * Parse Snapchat date string to JavaScript Date object
    * Format: "2025-11-30 00:31:09 UTC"
    */
    function parseSnapchatDate(dateStr) {
      try {
        // Remove " UTC" suffix and parse
        const dateStrClean = dateStr.replace(" UTC", "");
        return new Date(dateStrClean + "Z"); // Add Z to indicate UTC
      } catch (error) {
        console.error("mergeVideoOverlay error:", error);
        console.warn("Could not parse date:", dateStr, error);
        return new Date(); // Fallback to current date
      }
    }

    /**
     * Convert decimal degrees to degrees, minutes, seconds for EXIF
     */
    function decimalToDMS(decimal) {
      const absolute = Math.abs(decimal);
      const degrees = Math.floor(absolute);
      const minutesDecimal = (absolute - degrees) * 60;
      const minutes = Math.floor(minutesDecimal);
      const seconds = (minutesDecimal - minutes) * 60;

      return [
        [degrees, 1],
        [minutes, 1],
        [Math.round(seconds * 100), 100],
      ];
    }

    // Detect common file extension from file bytes (Uint8Array)
    function detectFileExtension(uint8array) {
      if (!uint8array || uint8array.length < 12) return null;
      // PNG
      if (uint8array[0] === 0x89 && uint8array[1] === 0x50 && uint8array[2] === 0x4e && uint8array[3] === 0x47) return '.png';
      // JPEG
      if (uint8array[0] === 0xff && uint8array[1] === 0xd8 && uint8array[2] === 0xff) return '.jpg';
      // WebP (RIFF....WEBP)
      if (
        uint8array[0] === 0x52 &&
        uint8array[1] === 0x49 &&
        uint8array[2] === 0x46 &&
        uint8array[3] === 0x46 &&
        uint8array[8] === 0x57 &&
        uint8array[9] === 0x45 &&
        uint8array[10] === 0x42 &&
        uint8array[11] === 0x50
      )
        return '.webp';
      // GIF
      if (uint8array[0] === 0x47 && uint8array[1] === 0x49 && uint8array[2] === 0x46) return '.gif';
      // MP4 (ftyp at bytes 4-7)
      if (
        uint8array.length >= 12 &&
        uint8array[4] === 0x66 &&
        uint8array[5] === 0x74 &&
        uint8array[6] === 0x79 &&
        uint8array[7] === 0x70
      )
        return '.mp4';
      return null;
    }

    /**
     * Add EXIF metadata (GPS and date) to JPEG image
     * @param {ArrayBuffer} imageData - Image data
     * @param {string} dateStr - Date string from Snapchat
     * @param {string} latitude - Latitude as string
     * @param {string} longitude - Longitude as string
     * @returns {Promise<ArrayBuffer>} - Image with EXIF metadata
     */
    async function addExifMetadata(imageData, dateStr, latitude, longitude) {
      if (typeof piexif === "undefined") {
        console.warn("piexif library not loaded, skipping EXIF metadata");
        return imageData;
      }

      try {
        // Convert ArrayBuffer to base64 for piexif
        const uint8Array = new Uint8Array(imageData);
        let binary = "";
        for (let i = 0; i < uint8Array.byteLength; i++) {
          binary += String.fromCharCode(uint8Array[i]);
        }
        const base64 = btoa(binary);
        const dataUrl = "data:image/jpeg;base64," + base64;

        // Create EXIF object
        const exifObj = { "0th": {}, Exif: {}, GPS: {} };

        // Add date/time
        if (dateStr && dateStr !== "Unknown") {
          try {
            const date = parseSnapchatDate(dateStr);
            const exifDate =
              date.getFullYear() +
              ":" +
              String(date.getMonth() + 1).padStart(2, "0") +
              ":" +
              String(date.getDate()).padStart(2, "0") +
              " " +
              String(date.getHours()).padStart(2, "0") +
              ":" +
              String(date.getMinutes()).padStart(2, "0") +
              ":" +
              String(date.getSeconds()).padStart(2, "0");

            exifObj["Exif"][piexif.ExifIFD.DateTimeOriginal] = exifDate;
            exifObj["Exif"][piexif.ExifIFD.DateTimeDigitized] = exifDate;
            exifObj["0th"][piexif.ImageIFD.DateTime] = exifDate;
          } catch (e) {
            console.warn("Could not parse date for EXIF:", e);
          }
        }

        // Add GPS coordinates
        if (
          latitude &&
          longitude &&
          latitude !== "Unknown" &&
          longitude !== "Unknown"
        ) {
          const lat = parseFloat(latitude);
          const lon = parseFloat(longitude);

          if (!isNaN(lat) && !isNaN(lon)) {
            // Latitude
            exifObj["GPS"][piexif.GPSIFD.GPSLatitude] = decimalToDMS(lat);
            exifObj["GPS"][piexif.GPSIFD.GPSLatitudeRef] =
              lat >= 0 ? "N" : "S";

            // Longitude
            exifObj["GPS"][piexif.GPSIFD.GPSLongitude] = decimalToDMS(lon);
            exifObj["GPS"][piexif.GPSIFD.GPSLongitudeRef] =
              lon >= 0 ? "E" : "W";
          }
        }

        // Insert EXIF into image
        const exifBytes = piexif.dump(exifObj);
        const newDataUrl = piexif.insert(exifBytes, dataUrl);

        // Convert back to ArrayBuffer
        const newBase64 = newDataUrl.split(",")[1];
        const newBinary = atob(newBase64);
        const newUint8Array = new Uint8Array(newBinary.length);
        for (let i = 0; i < newBinary.length; i++) {
          newUint8Array[i] = newBinary.charCodeAt(i);
        }

        return newUint8Array.buffer;
      } catch (error) {
        console.warn("Could not add EXIF metadata:", error);
        return imageData;
      }
    }

    /**
     * Merge overlay image on top of main image using Canvas API
     * @param {ArrayBuffer} mainData - Main image data
     * @param {ArrayBuffer} overlayData - Overlay image data
     * @returns {Promise<ArrayBuffer>} - Merged image as JPEG
     */
    async function mergeImageOverlay(mainData, overlayData) {
      return new Promise((resolve, reject) => {
        // Create blobs
        const mainBlob = new Blob([mainData]);
        const overlayBlob = new Blob([overlayData]);

        // Create image URLs
        const mainUrl = URL.createObjectURL(mainBlob);
        const overlayUrl = URL.createObjectURL(overlayBlob);

        // Load main image
        const mainImg = new Image();
        const overlayImg = new Image();

        let mainLoaded = false;
        let overlayLoaded = false;

        function tryMerge() {
          if (!mainLoaded || !overlayLoaded) return;

          try {
            // Create canvas with main image dimensions
            const canvas = document.createElement("canvas");
            canvas.width = mainImg.width;
            canvas.height = mainImg.height;
            const ctx = canvas.getContext("2d");

            // Draw main image
            ctx.drawImage(mainImg, 0, 0);

            // Draw overlay on top (scaled if needed)
            ctx.drawImage(overlayImg, 0, 0, canvas.width, canvas.height);

            // Convert to blob
            canvas.toBlob(
              (blob) => {
                // Clean up URLs
                URL.revokeObjectURL(mainUrl);
                URL.revokeObjectURL(overlayUrl);

                // Convert blob to arraybuffer
                blob.arrayBuffer().then(resolve).catch(reject);
              },
              "image/jpeg",
              0.95
            );
          } catch (error) {
            URL.revokeObjectURL(mainUrl);
            URL.revokeObjectURL(overlayUrl);
            reject(error);
          }
        }

        mainImg.onload = () => {
          mainLoaded = true;
          tryMerge();
        };
        mainImg.onerror = () => {
          URL.revokeObjectURL(mainUrl);
          URL.revokeObjectURL(overlayUrl);
          reject(new Error("Failed to load main image"));
        };

        overlayImg.onload = () => {
          overlayLoaded = true;
          tryMerge();
        };
        overlayImg.onerror = () => {
          URL.revokeObjectURL(mainUrl);
          URL.revokeObjectURL(overlayUrl);
          reject(new Error("Failed to load overlay image"));
        };

        mainImg.src = mainUrl;
        overlayImg.src = overlayUrl;
      });
    }

    /**
     * Convert any image format to PNG using Canvas API
     * This ensures FFmpeg.wasm compatibility (WebP, JPEG, etc. ‚Üí PNG)
     * @param {ArrayBuffer} imageData - Image data in any format
     * @param {string} originalExt - Original file extension (for logging)
     * @returns {Promise<ArrayBuffer>} - PNG image data
     */
    async function convertImageToPNG(imageData, originalExt) {
      return new Promise((resolve, reject) => {
        const blob = new Blob([imageData]);
        const url = URL.createObjectURL(blob);
        const img = new Image();

        img.onload = () => {
          try {
            // Create canvas matching image dimensions
            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;

            // Draw image to canvas
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);

            // Convert to PNG blob
            canvas.toBlob((pngBlob) => {
              if (!pngBlob) {
                URL.revokeObjectURL(url);
                reject(new Error('Failed to create PNG blob'));
                return;
              }

              // Convert blob to ArrayBuffer
              pngBlob.arrayBuffer().then(arrayBuffer => {
                URL.revokeObjectURL(url);
                resolve(arrayBuffer);
              }).catch(err => {
                URL.revokeObjectURL(url);
                reject(err);
              });
            }, 'image/png', 1.0); // Full quality PNG

          } catch (error) {
            URL.revokeObjectURL(url);
            reject(error);
          }
        };

        img.onerror = () => {
          URL.revokeObjectURL(url);
          reject(new Error(`Failed to load image as ${originalExt}`));
        };

        img.src = url;
      });
    }

    /**
     * Merge overlay video on top of main video using FFmpeg.wasm
     * @param {ArrayBuffer} mainData - Main video data
     * @param {ArrayBuffer} overlayData - Overlay video data
     * @param {Function} progressCallback - Optional progress callback (receives percentage)
     * @returns {Promise<ArrayBuffer>} - Merged video
     */
    async function mergeVideoOverlay(
      mainData,
      overlayData,
      progressCallback,
      overlayIsImage = false,
      overlayExt = '.mp4'
    ) {
      const ffmpeg = await initFFmpeg(); // Will auto-reset if needed

      if (!ffmpeg) {
        throw new Error("FFmpeg.wasm not available");
      }

      let overlayFilename;
      try {
        // Write input files to FFmpeg virtual filesystem
        await ffmpeg.writeFile("main.mp4", new Uint8Array(mainData));

        // Convert image overlays to PNG for FFmpeg.wasm compatibility
        if (overlayIsImage) {
          addLog(`  Converting ${overlayExt} overlay to PNG for FFmpeg compatibility...`, 'info', 'ffmpeg');
          try {
            const pngData = await convertImageToPNG(overlayData, overlayExt);
            overlayFilename = 'overlay.png';
            await ffmpeg.writeFile(overlayFilename, new Uint8Array(pngData));
            addLog('  ‚úì Overlay converted to PNG', 'success', 'ffmpeg');
          } catch (convertError) {
            addLog(`  Warning: PNG conversion failed, using original format: ${convertError.message}`, 'warning', 'ffmpeg');
            overlayFilename = `overlay${overlayExt}`;
            await ffmpeg.writeFile(overlayFilename, new Uint8Array(overlayData));
          }
        } else {
          overlayFilename = 'overlay.mp4';
          await ffmpeg.writeFile(overlayFilename, new Uint8Array(overlayData));
        }

        // Set up progress logging
        ffmpeg.on("progress", ({ progress }) => {
          if (progressCallback) {
            const percent = Math.round(progress * 100);
            progressCallback(percent);
            addLog(`Encoding progress: ${percent}%`, 'ffmpeg', 'ffmpeg');
          }
        });

        // Probe main video to get dimensions to properly scale overlay
        let mainWidth = null;
        let mainHeight = null;
        try {
          const probeRaw = await ffmpeg.ffprobe([
            "-v",
            "error",
            "-select_streams",
            "v:0",
            "-show_entries",
            "stream=width,height",
            "-of",
            "json",
            "main.mp4",
          ]);
          try {
            const probeJson = JSON.parse(probeRaw);
            if (probeJson.streams && probeJson.streams[0]) {
              mainWidth = probeJson.streams[0].width;
              mainHeight = probeJson.streams[0].height;
            }
          } catch (e) {
            // If parse fails, try regex parse fallback
            try {
              const matchW = probeRaw.match(/"width"\s*:\s*(\d+)/);
              const matchH = probeRaw.match(/"height"\s*:\s*(\d+)/);
              if (matchW) mainWidth = parseInt(matchW[1], 10);
              if (matchH) mainHeight = parseInt(matchH[1], 10);
            } catch (e2) {
              // Ignore
            }
          }
        } catch (probeError) {
          addLog(`    FFprobe failed: ${(probeError && probeError.message) || String(probeError)}`, "info");
          console.warn('FFprobe failed:', probeError);
        }

        if (mainWidth && mainHeight) {
          addLog(`    main video dimensions: ${mainWidth}x${mainHeight}`, 'info');
        }

        // FFmpeg command arguments ‚Äî handle image overlay vs video overlay
        let args;
        if (overlayIsImage) {
          // overlay is an image (png/jpg/etc.)
          let scaleStr = '';
          if (mainWidth && mainHeight) scaleStr = `${mainWidth}:${mainHeight}`;
          else scaleStr = 'iw:ih';
          args = [
            "-i",
            "main.mp4",
            "-loop",
            "1",
            "-i",
            overlayFilename,
            "-filter_complex",
            // Scale overlay to main video and center using explicit dimensions
            `[1:v]scale=${scaleStr}[ovr];[0:v][ovr]overlay=x=(main_w-overlay_w)/2:y=(main_h-overlay_h)/2:format=auto:shortest=1[outv]`,
            "-map",
            "[outv]",
            "-map",
            "0:a?",
            "-c:v",
            "libx264",
            "-preset",
            "ultrafast",
            "-crf",
            "23",
            "-pix_fmt",
            "yuv420p",
            "-c:a",
            "copy",
            "-movflags",
            "+faststart",
            "-y",
            "output.mp4",
          ];
        } else {
          // overlay is a video
          // Detect Firefox and use simpler filter chain
          const isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
          let filterComplex;
          let preset = "medium";

          // Use SIMPLEST possible filter for ALL browsers
          // Complex filters (fps, setsar, loop, setpts) cause black screen in WASM FFmpeg
          addLog('  Using simplified filter chain for WASM compatibility', 'info', 'ffmpeg');

          if (mainWidth && mainHeight) {
            // We have dimensions - use them
            filterComplex = `[1:v]scale=${mainWidth}:${mainHeight}[ovr];[0:v][ovr]overlay=shortest=1`;
            addLog(`  Scaling overlay to ${mainWidth}x${mainHeight}`, 'info', 'ffmpeg');
          } else {
            // No dimensions - overlay keeps its size
            filterComplex = `[0:v][1:v]overlay=shortest=1`;
            addLog('  Using overlay at original size (no scaling)', 'warning', 'ffmpeg');
          }

          preset = isFirefox ? "veryfast" : "medium";

          args = [
            "-i",
            "main.mp4",
            "-i",
            overlayFilename,
            "-filter_complex",
            filterComplex,
            "-map",
            "0:a?", // Map audio from main video
            "-c:v",
            "libx264",
            "-preset",
            preset,
            "-crf",
            "23",
            "-pix_fmt",
            "yuv420p",
            "-c:a",
            "copy",
            "-movflags",
            "+faststart",
            "-shortest", // Stop at shortest input
            "-y",
            "output.mp4",
          ];
        }

        // Execute FFmpeg
        addLog(`Starting video merge (overlay type: ${overlayIsImage ? 'image' : 'video'})`, 'info', 'ffmpeg');
        addLog(`FFmpeg command: ${args.join(' ')}`, 'ffmpeg', 'ffmpeg');

        try {
          await ffmpeg.exec(args);
          addLog('Video merge completed successfully', 'success', 'ffmpeg');
        } catch (execError) {
          addLog(`FFmpeg execution error: ${execError.message || String(execError)}`, 'error', 'ffmpeg');
          throw new Error(`FFmpeg execution failed: ${execError.message || String(execError)}`);
        }

        // Read output file
        const outputData = await ffmpeg.readFile("output.mp4");

        // Validate output size
        if (outputData.byteLength < 1000) {
          addLog(`WARNING: Output video is suspiciously small (${outputData.byteLength} bytes)`, 'error', 'ffmpeg');
          throw new Error(`Output video too small: ${outputData.byteLength} bytes - likely encoding failure`);
        }

        addLog(`Output video size: ${formatBytes(outputData.byteLength)}`, 'success', 'ffmpeg');

        // Clean up virtual filesystem
        await ffmpeg.deleteFile("main.mp4").catch(() => {});
        if (overlayFilename) await ffmpeg.deleteFile(overlayFilename).catch(() => {});
        await ffmpeg.deleteFile("output.mp4").catch(() => {});

        // Remove progress listener
        ffmpeg.off("progress");

        // Increment success counter
        videosProcessedSinceReset++;
        totalVideosProcessed++;

        // Convert Uint8Array to ArrayBuffer
        return outputData.buffer;
      } catch (error) {
        // Clean up on error
        try {
          await ffmpeg.deleteFile("main.mp4").catch(() => { });
          if (overlayFilename) await ffmpeg.deleteFile(overlayFilename).catch(() => { });
          await ffmpeg.deleteFile("output.mp4").catch(() => { });
          ffmpeg.off("progress");
        } catch (cleanupError) {
          // Ignore cleanup errors
        }

        // On error, terminate FFmpeg instance to ensure clean state for next video
        addLog('  Video merge failed, resetting FFmpeg for next attempt', 'info');
        await terminateFFmpeg();

        // Normalize and wrap the error so downstream handlers can log details
        let errorMsg = "";
        try {
          errorMsg = error && (error.message || String(error) || JSON.stringify(error));
        } catch (e) {
          errorMsg = "Unknown error";
        }
        const enhanced = new Error(`FFmpeg merge failed: ${errorMsg}`);
        if (error && error.stack) enhanced.stack = error.stack;
        throw enhanced;
      }
    }

    // Drag and drop handlers
    uploadSection.addEventListener("dragover", (e) => {
      e.preventDefault();
      uploadSection.classList.add("dragover");
    });

    uploadSection.addEventListener("dragleave", () => {
      uploadSection.classList.remove("dragover");
    });

    uploadSection.addEventListener("drop", (e) => {
      e.preventDefault();
      uploadSection.classList.remove("dragover");
      const files = e.dataTransfer.files;
      if (files.length > 0) {
        handleFile(files[0]);
      }
    });

    fileInput.addEventListener("change", (e) => {
      if (e.target.files.length > 0) {
        handleFile(e.target.files[0]);
      }
    });

    metadataInput.addEventListener("change", async (e) => {
      if (e.target.files.length > 0) {
        const file = e.target.files[0];
        metadataFileName.textContent = file.name;
        try {
          const text = await file.text();
          existingMetadata = JSON.parse(text);
          addLog(
            `Loaded metadata.json with ${existingMetadata.length} entries`,
            "success"
          );
        } catch (error) {
          addLog(`Error loading metadata.json: ${error.message}`, "error");
          existingMetadata = null;
        }
      }
    });

    /**
     * Add log entry to appropriate tab
     * @param {string} message - Log message
     * @param {string} type - Log type: info, success, error, warning, ffmpeg
     * @param {string} tab - Which tab: 'main' or 'ffmpeg'
     */
    function addLog(message, type = "info", tab = "main") {
      const logContainer = tab === "ffmpeg" ? document.getElementById("logFFmpeg") : document.getElementById("log");
      const entry = document.createElement("div");
      entry.className = `log-entry ${type}`;
      entry.textContent = message;
      logContainer.appendChild(entry);
      logContainer.scrollTop = logContainer.scrollHeight;
    }

    /**
     * Switch between log tabs
     */
    function switchLogTab(tabName) {
      // Update tab buttons
      document.querySelectorAll('.log-tab').forEach(tab => {
        tab.classList.remove('active');
      });
      event.target.classList.add('active');

      // Update content
      document.querySelectorAll('.log-content').forEach(content => {
        content.classList.remove('active');
      });
      document.getElementById(`log-${tabName}`).classList.add('active');
    }

    /**
     * Copy all logs to clipboard for easy sharing/debugging
     */
    async function copyLogsToClipboard() {
      const mainLogEntries = document.querySelectorAll('#log .log-entry');
      const ffmpegLogEntries = document.querySelectorAll('#logFFmpeg .log-entry');

      let logText = '=== MAIN ACTIVITY LOG ===\n';
      logText += Array.from(mainLogEntries).map(entry => entry.textContent).join('\n');

      if (ffmpegLogEntries.length > 0) {
        logText += '\n\n=== FFMPEG DETAILS ===\n';
        logText += Array.from(ffmpegLogEntries).map(entry => entry.textContent).join('\n');
      }

      try {
        await navigator.clipboard.writeText(logText);

        // Visual feedback
        const btn = document.getElementById('copyLogsBtn');
        const originalText = btn.innerHTML;
        btn.innerHTML = '‚úÖ Copied!';
        btn.style.background = '#28a745';

        setTimeout(() => {
          btn.innerHTML = originalText;
          btn.style.background = '#667eea';
        }, 2000);

        addLog('Logs copied to clipboard!', 'success');
      } catch (err) {
        // Fallback for older browsers
        const textarea = document.createElement('textarea');
        textarea.value = logText;
        textarea.style.position = 'fixed';
        textarea.style.opacity = '0';
        document.body.appendChild(textarea);
        textarea.select();

        try {
          document.execCommand('copy');
          addLog('Logs copied to clipboard!', 'success');

          const btn = document.getElementById('copyLogsBtn');
          const originalText = btn.innerHTML;
          btn.innerHTML = '‚úÖ Copied!';
          btn.style.background = '#28a745';

          setTimeout(() => {
            btn.innerHTML = originalText;
            btn.style.background = '#667eea';
          }, 2000);
        } catch (e) {
          addLog('Failed to copy logs. Please select and copy manually.', 'error');
        }

        document.body.removeChild(textarea);
      }
    }

    function updateProgress(current, total) {
      const percent = Math.round((current / total) * 100);
      progressFill.style.width = `${percent}%`;
      progressFill.textContent = `${percent}%`;
      status.textContent = `Processing ${current} of ${total} memories...`;
    }

    async function handleFile(file) {
      if (!file.name.endsWith(".html")) {
        alert("Please upload an HTML file");
        return;
      }

      fileName.textContent = file.name;
      addLog("Reading file...", "info");

      const text = await file.text();
      parseHTML(text);
    }

    function parseHTML(htmlText) {
      addLog("Parsing HTML...", "info");

      const parser = new DOMParser();
      const doc = parser.parseFromString(htmlText, "text/html");
      const rows = doc.querySelectorAll("tr");

      memories = [];

      rows.forEach((row) => {
        const cells = row.querySelectorAll("td");
        if (cells.length >= 4) {
          const dateCell = cells[0].textContent.trim();
          const typeCell = cells[1].textContent.trim();
          const locationCell = cells[2].textContent.trim();
          const link = cells[3].querySelector("a");

          if (dateCell.includes("UTC") && link) {
            const onclickAttr = link.getAttribute("onclick");
            const urlMatch = onclickAttr
              ? onclickAttr.match(/downloadMemories\('([^']+)'/)
              : null;

            if (urlMatch) {
              const locationMatch = locationCell.match(
                /Latitude, Longitude:\s*([-\d.]+),\s*([-\d.]+)/
              );

              memories.push({
                date: dateCell,
                mediaType: typeCell,
                latitude: locationMatch ? locationMatch[1] : "Unknown",
                longitude: locationMatch ? locationMatch[2] : "Unknown",
                url: urlMatch[1],
              });
            }
          }
        }
      });

      if (memories.length === 0) {
        addLog("No memories found in file!", "error");
        alert(
          "No memories found in the HTML file. Please make sure you uploaded the correct memories_history.html file."
        );
        return;
      }

      addLog(`Found ${memories.length} memories`, "success");
      addLog(
        'Ready to download! Click the "Start Download" button when ready.',
        "info"
      );

      // Show the start button
      startButton.style.display = "inline-block";
    }

    function handleStartDownload() {
      // Hide the start button and show progress
      startButton.style.display = "none";
      progressContainer.style.display = "block";

      // Start the download
      startDownload();
    }

    async function startDownload() {
      currentIndex = 0;

      // Initialize or use existing metadata
      let metadataList = existingMetadata || [];

      // If no existing metadata, create new entries with pending status
      if (!existingMetadata) {
        for (let i = 0; i < memories.length; i++) {
          const memory = memories[i];
          metadataList.push({
            number: i + 1,
            date: memory.date,
            media_type: memory.mediaType,
            latitude: memory.latitude,
            longitude: memory.longitude,
            url: memory.url,
            status: "pending",
            files: [],
          });
        }
        addLog("Initialized metadata for all memories", "info");
      } else {
        addLog(
          "Using existing metadata - will skip successful downloads",
          "info"
        );
      }

      // Check media type filters
      const videosOnly =
        document.getElementById("videosOnlyCheckbox").checked;
      const picturesOnly = document.getElementById(
        "picturesOnlyCheckbox"
      ).checked;

      // Determine which items to download
      let itemsToDownload = metadataList.map((m, i) => ({
        metadata: m,
        index: i,
      }));

      // Apply media type filters
      if (videosOnly) {
        itemsToDownload = itemsToDownload.filter(
          (item) => item.metadata.media_type === "Video"
        );
        addLog(
          `Videos-only mode: ${itemsToDownload.length} videos to process`,
          "info"
        );
      } else if (picturesOnly) {
        itemsToDownload = itemsToDownload.filter(
          (item) => item.metadata.media_type === "Image"
        );
        addLog(
          `Pictures-only mode: ${itemsToDownload.length} pictures to process`,
          "info"
        );
      } else {
        // Normal mode: skip successfully downloaded items
        itemsToDownload = itemsToDownload.filter(
          (item) =>
            item.metadata.status !== "success" ||
            !item.metadata.files ||
            item.metadata.files.length === 0
        );
        addLog(
          `${itemsToDownload.length} items to download (${metadataList.length - itemsToDownload.length
          } already completed)`,
          "info"
        );
      }

      if (itemsToDownload.length === 0) {
        addLog("All memories already downloaded!", "success");
        status.textContent = "All downloads complete!";
        progressFill.style.width = "100%";
        progressFill.textContent = "100%";
        return;
      }

      // Get batch size
      const batchSize = parseInt(
        document.getElementById("batchSizeSelect").value
      );
      const useBatching = batchSize > 0;

      if (useBatching) {
        const numBatches = Math.ceil(itemsToDownload.length / batchSize);
        addLog(
          `Will create ${numBatches} batch(es) of up to ${batchSize} files each`,
          "info"
        );

        // Process in batches
        for (let batchNum = 0; batchNum < numBatches; batchNum++) {
          const batchStart = batchNum * batchSize;
          const batchEnd = Math.min(
            batchStart + batchSize,
            itemsToDownload.length
          );
          const batchItems = itemsToDownload.slice(batchStart, batchEnd);

          addLog(
            `\nProcessing Batch ${batchNum + 1}/${numBatches} (${batchItems.length
            } items)`,
            "info"
          );

          await processBatch(
            batchItems,
            metadataList,
            batchNum + 1,
            batchStart,
            itemsToDownload.length
          );
        }
      } else {
        // Process all at once
        addLog("Processing all items in a single ZIP", "info");
        await processBatch(
          itemsToDownload,
          metadataList,
          0,
          0,
          itemsToDownload.length
        );
      }

      // Final summary
      const successful = metadataList.filter(
        (m) => m.status === "success"
      ).length;
      const failed = metadataList.filter((m) => m.status === "failed").length;
      const pending = metadataList.filter(
        (m) => m.status === "pending"
      ).length;

      addLog(
        `\n‚úì Complete! ${successful} successful, ${failed} failed, ${pending} pending`,
        "success"
      );

      if (failed > 0 || pending > 0) {
        addLog(
          `Tip: Download metadata.json from any batch ZIP and re-upload it to retry failed/pending items`,
          "info"
        );
      }

      status.textContent = "All downloads complete!";
      progressFill.style.width = "100%";
      progressFill.textContent = "100%";
    }

    /**
     * Process a batch of items with ZERO video memory accumulation
     *
     * STRATEGY: As soon as we encounter a video needing merge:
     * 1. Download current batch (all items processed so far)
     * 2. Process video individually in its own ZIP
     * 3. Continue with fresh batch
     *
     * This ensures merged videos NEVER accumulate in memory.
     */
    async function processBatch(
      batchItems,
      metadataList,
      batchNum,
      globalStartIndex,
      totalItems
    ) {
      zip = new JSZip();
      let subBatchNum = 0;
      let itemsInCurrentZip = 0;

      const mergeEnabled = document.getElementById('mergeOverlaysCheckbox').checked;

      addLog(`Batch ${batchNum}: ${batchItems.length} items to process`, 'info');

      for (let i = 0; i < batchItems.length; i++) {
        const item = batchItems[i];
        const globalCount = globalStartIndex + i + 1;
        const isVideo = item.metadata.media_type === 'Video';

        // Check if this video will need merging
        const needsMerge = isVideo && mergeEnabled;

        // If we encounter a video needing merge and we have items in the current ZIP, flush it
        if (needsMerge && itemsInCurrentZip > 0) {
          addLog(`  Downloading batch before video merge (${itemsInCurrentZip} items)...`, 'info');
          await downloadCurrentBatch(metadataList, batchNum, subBatchNum);
          subBatchNum++;
          zip = new JSZip();
          itemsInCurrentZip = 0;
          checkMemoryUsage();
        }

        // Process the item
        await processItem(item, globalCount, totalItems, metadataList);
        itemsInCurrentZip++;

        // If this was a video that needed merging, download it immediately in its own ZIP
        if (needsMerge) {
          addLog(`  Downloading merged video individually...`, 'info');
          await downloadCurrentBatch(metadataList, batchNum, subBatchNum, `video-${item.metadata.number}`);
          subBatchNum++;
          zip = new JSZip();
          itemsInCurrentZip = 0;

          // Extra GC time after video
          addLog('  Pausing 2s for garbage collection...', 'info');
          await new Promise(resolve => setTimeout(resolve, 2000));
          checkMemoryUsage();
        }
      }

      // Download any remaining items
      if (itemsInCurrentZip > 0) {
        addLog(`  Downloading final batch (${itemsInCurrentZip} items)...`, 'info');
        await downloadCurrentBatch(metadataList, batchNum, subBatchNum);
      }
    }

    /**
     * Download the current ZIP batch
     */
    async function downloadCurrentBatch(metadataList, batchNum, subBatchNum, suffix = '') {
      // Add metadata.json to zip
      zip.file("metadata.json", JSON.stringify(metadataList, null, 2));

      // Generate filename
      let filename;
      if (suffix) {
        filename = `snapchat-memories-batch-${batchNum}-${suffix}.zip`;
      } else if (subBatchNum > 0) {
        filename = `snapchat-memories-batch-${batchNum}-part-${subBatchNum + 1}.zip`;
      } else if (batchNum > 0) {
        filename = `snapchat-memories-batch-${batchNum}.zip`;
      } else {
        filename = "snapchat-memories.zip";
      }

      status.textContent = `Creating ${filename}...`;
      addLog(`  Packaging ${filename}...`, "info");

      const zipBlob = await zip.generateAsync(
        { type: "blob" },
        (metadata) => {
          const percent = Math.round(metadata.percent);
          progressFill.style.width = `${percent}%`;
          progressFill.textContent = `${percent}%`;
        }
      );

      // Download the ZIP file
      const url = URL.createObjectURL(zipBlob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);

      addLog(`  ‚úì Downloaded: ${filename} (${formatBytes(zipBlob.size)})`, "success");
    }

    /**
     * Process a single item (image or video)
     * Extracted from processBatch to support smart batching
     */
    async function processItem(batchItem, globalCount, totalItems, metadataList) {
      const { metadata, index: i } = batchItem;
      const memory = memories[i];
      const fileNum = String(metadata.number).padStart(2, "0");
      const extension = metadata.media_type === "Video" ? ".mp4" : ".jpg";

      updateProgress(globalCount, totalItems);
      addLog(
        `[${globalCount}/${totalItems}] #${metadata.number} ${metadata.date} - ${metadata.media_type}`,
        "info"
      );

      // Mark as in progress
      metadata.status = "in_progress";

      try {
        addLog(`    Fetching: ${metadata.url}`, "info");
        console.log("Fetching:", metadata.url);
        const response = await fetch(metadata.url);
        if (!response.ok) {
          const bodyText = await response.text().catch(() => "<no body>");
          addLog(`    HTTP error ${response.status} while fetching ${metadata.url}`, "error");
          console.error(`HTTP ${response.status} fetching ${metadata.url}:`, bodyText);
          throw new Error(`HTTP ${response.status}`);
        }

        const blob = await response.blob();
        const arrayBuffer = await blob.arrayBuffer();

        // Validate downloaded content
        if (arrayBuffer.byteLength < 100) {
          addLog(
            `    WARNING: Downloaded file is very small (${arrayBuffer.byteLength} bytes) - may be invalid or expired URL`,
            "warning"
          );
        }

        // Check if it's a ZIP file (overlay content)
        const uint8Array = new Uint8Array(arrayBuffer);
        const isZip = uint8Array[0] === 0x50 && uint8Array[1] === 0x4b;

        // For videos, check if it looks like a valid MP4 file
        if (
          metadata.media_type === "Video" &&
          !isZip &&
          arrayBuffer.byteLength >= 8
        ) {
          // Check for MP4 magic bytes (ftyp box at bytes 4-8)
          const signature = String.fromCharCode(...uint8Array.slice(4, 8));
          const validSignatures = ["ftyp", "mdat", "moov", "wide"];
          if (!validSignatures.includes(signature)) {
            addLog(
              `    WARNING: File may not be a valid video (invalid MP4 signature)`,
              "warning"
            );
            addLog(
              `    First bytes: ${Array.from(uint8Array.slice(0, 20))
                .map((b) => b.toString(16).padStart(2, "0"))
                .join(" ")}`,
              "warning"
            );
            addLog(
              `    This might be an HTML error page or expired download link`,
              "warning"
            );
          }
        }

        // Reset files array
        metadata.files = [];

        if (isZip) {
            // Extract ZIP contents
            const innerZip = await JSZip.loadAsync(arrayBuffer);
            const files = Object.keys(innerZip.files);

            // Check if we should merge overlays
            const mergeOverlays = document.getElementById(
              "mergeOverlaysCheckbox"
            ).checked;
            const isImage = metadata.media_type === "Image";
            const isVideo = metadata.media_type === "Video";
            const hasOverlay = files.some((f) =>
              f.toLowerCase().includes("overlay")
            );

            // Try to merge if checkbox is checked and has overlay
            if (mergeOverlays && hasOverlay && files.length === 2) {
              if (isImage) {
                try {
                  // Get main and overlay files
                  let mainData = null;
                  let overlayData = null;

                  for (const filename of files) {
                    const fileData = await innerZip.files[filename].async(
                      "arraybuffer"
                    );
                    if (filename.toLowerCase().includes("overlay")) {
                      overlayData = fileData;
                    } else {
                      mainData = fileData;
                    }
                  }

                  if (mainData && overlayData) {
                    // Merge the images
                    let mergedData = await mergeImageOverlay(
                      mainData,
                      overlayData
                    );

                    // Add EXIF metadata to merged image
                    mergedData = await addExifMetadata(
                      mergedData,
                      metadata.date,
                      metadata.latitude,
                      metadata.longitude
                    );

                    const filename = `${fileNum}${extension}`;

                    // Add to ZIP with original date
                    const fileDate = parseSnapchatDate(metadata.date);
                    zip.file(filename, mergedData, { date: fileDate });
                    metadata.files.push({
                      path: filename,
                      size: mergedData.byteLength,
                      type: "merged",
                    });
                    addLog(
                      `  Merged overlay: ${filename} (${formatBytes(
                        mergedData.byteLength
                      )})`,
                      "success"
                    );
                  } else {
                    throw new Error("Missing main or overlay file");
                  }
                } catch (error) {
                  // Normalize error
                  let errorMsg = "";
                  try {
                    errorMsg = error && (error.message || String(error) || JSON.stringify(error));
                  } catch (e) {
                    errorMsg = "Unknown error";
                  }
                  addLog(
                    `  Warning: Failed to merge overlay (${errorMsg}), saving separately`,
                    "info"
                  );
                  console.error("Failed to merge overlay", error);
                  // Debug details
                  try {
                    addLog(`    overlay name: ${overlayName || 'unknown'}`, "info");
                    const overlayBytes = overlayData ? new Uint8Array(overlayData).length : 0;
                    addLog(`    overlay size: ${overlayBytes} bytes`, "info");
                    const detected = overlayData ? detectFileExtension(new Uint8Array(overlayData)) : null;
                    addLog(`    overlay detected ext: ${detected || 'unknown'}`, "info");
                  } catch (debugError) {
                    addLog(`    Debug info failed: ${(debugError && debugError.message) || String(debugError)}`, "info");
                  }
                  if (error && error.stack) addLog(`    Stack: ${error.stack}`, "info");
                  // Fall back to saving separately
                  const fileDate = parseSnapchatDate(metadata.date);
                  for (const filename of files) {
                    let fileData = await innerZip.files[filename].async(
                      "arraybuffer"
                    );
                    const isOverlay = filename
                      .toLowerCase()
                      .includes("overlay");
                    // Preserve original extension if present in inner filename
                    let origExt = filename.includes('.') ? filename.substring(filename.lastIndexOf('.')) : null;
                    if (!origExt) {
                      const detected = detectFileExtension(new Uint8Array(fileData));
                      origExt = detected || extension;
                    }
                    const newFilename = isOverlay
                      ? `${fileNum}-overlay${origExt}`
                      : `${fileNum}-main${origExt}`;

                    // Add EXIF metadata to images
                    if (metadata.media_type === "Image") {
                      fileData = await addExifMetadata(
                        fileData,
                        metadata.date,
                        metadata.latitude,
                        metadata.longitude
                      );
                    }

                    zip.file(newFilename, fileData, { date: fileDate });
                    addLog(`    Saved extracted file: ${newFilename} (${formatBytes(fileData.byteLength)})`, "info");
                    metadata.files.push({
                      path: newFilename,
                      size: fileData.byteLength,
                      type: isOverlay ? "overlay" : "main",
                    });
                  }
                  addLog(
                    `  Extracted ${files.length} files from ZIP`,
                    "success"
                  );
                }
              } else if (isVideo) {
                try {
                  addLog(
                    `  Merging video overlay (please wait, this may take a minute)...`,
                    "info"
                  );

                  // Get main and overlay files (preserve original filenames/extensions)
                  let mainData = null;
                  let overlayData = null;
                  let mainName = null;
                  let overlayName = null;

                  for (const filename of files) {
                    const fileData = await innerZip.files[filename].async(
                      "arraybuffer"
                    );
                    if (filename.toLowerCase().includes("overlay")) {
                      overlayData = fileData;
                      overlayName = filename;
                    } else {
                      mainData = fileData;
                      mainName = filename;
                    }
                  }

                  if (mainData && overlayData) {
                    // Determine overlay extension and whether it's an image
                    let overlayExt = overlayName && overlayName.includes('.')
                      ? overlayName.substring(overlayName.lastIndexOf('.'))
                      : null;
                    // Try to detect from data if no extension or ambiguous
                    const detectedOverlayExt = detectFileExtension(new Uint8Array(overlayData));
                    if (detectedOverlayExt) overlayExt = detectedOverlayExt;
                    if (!overlayExt) overlayExt = '.mp4';
                    const overlayExtNoDot = overlayExt.replace('.', '').toLowerCase();
                    const overlayIsImage = ['png', 'jpg', 'jpeg', 'webp', 'gif'].includes(overlayExtNoDot);

                    // Merge videos using FFmpeg.wasm (supports image overlay)
                    const mergedData = await mergeVideoOverlay(
                      mainData,
                      overlayData,
                      (progress) => {
                        addLog(
                          `    Video merge progress: ${progress}%`,
                          "info"
                        );
                      },
                      overlayIsImage,
                      overlayExt
                    );

                    const filename = `${fileNum}${extension}`;

                    // Add to ZIP with original date
                    const fileDate = parseSnapchatDate(metadata.date);
                    zip.file(filename, mergedData, { date: fileDate });
                    metadata.files.push({
                      path: filename,
                      size: mergedData.byteLength,
                      type: "merged",
                    });
                    addLog(
                      `  Merged video: ${filename} (${formatBytes(
                        mergedData.byteLength
                      )})`,
                      "success"
                    );

                    // Check memory after video processing
                    checkMemoryUsage();
                  } else {
                    throw new Error("Missing main or overlay video file");
                  }
                } catch (error) {
                  // Normalize the error into a readable message
                  let errorMsg = "";
                  try {
                    errorMsg = error && (error.message || String(error) || JSON.stringify(error));
                  } catch (e) {
                    errorMsg = "Unknown error";
                  }

                  addLog(
                    `  Warning: Failed to merge video overlay (${errorMsg}), saving separately`,
                    "info"
                  );
                  console.error("Failed to merge video overlay", error);

                  // Additional debug information
                  try {
                    const mainBytes = mainData ? new Uint8Array(mainData).length : 0;
                    const overlayBytes = overlayData ? new Uint8Array(overlayData).length : 0;
                    addLog(`    main size: ${mainBytes} bytes`, "info");
                    addLog(`    overlay size: ${overlayBytes} bytes`, "info");

                    // Derive overlay ext and detection info for debugging
                    let overlayDetectedExt = overlayName && overlayName.includes('.') ? overlayName.substring(overlayName.lastIndexOf('.')) : null;
                    const detectedOverlayFromBytes = overlayData ? detectFileExtension(new Uint8Array(overlayData)) : null;
                    if (detectedOverlayFromBytes) overlayDetectedExt = detectedOverlayFromBytes;
                    overlayDetectedExt = overlayDetectedExt || 'unknown';
                    const overlayIsImageDetected = ['.png', '.jpg', '.jpeg', '.webp', '.gif'].includes((overlayDetectedExt || '').replace('.', '').toLowerCase());
                    addLog(`    overlay name: ${overlayName || 'unknown'}`, "info");
                    addLog(`    overlay detected ext: ${overlayDetectedExt} (image? ${overlayIsImageDetected})`, "info");
                  } catch (debugError) {
                    addLog(`    Debug info collection failed: ${(debugError && debugError.message) || String(debugError)}`, "info");
                  }

                  // Dump stack if available
                  if (error && error.stack) {
                    addLog(`    Stack: ${error.stack}`, "info");
                  }
                  // Fall back to saving separately
                  const fileDate = parseSnapchatDate(metadata.date);
                  for (const filename of files) {
                    let fileData = await innerZip.files[filename].async(
                      "arraybuffer"
                    );
                    const isOverlay = filename
                      .toLowerCase()
                      .includes("overlay");
                    let origExt = filename.includes('.') ? filename.substring(filename.lastIndexOf('.')) : null;
                    if (!origExt) {
                      const detected = detectFileExtension(new Uint8Array(fileData));
                      origExt = detected || extension;
                    }
                    const newFilename = isOverlay
                      ? `${fileNum}-overlay${origExt}`
                      : `${fileNum}-main${origExt}`;

                    zip.file(newFilename, fileData, { date: fileDate });
                    metadata.files.push({
                      path: newFilename,
                      size: fileData.byteLength,
                      type: isOverlay ? "overlay" : "main",
                    });
                  }
                  addLog(
                    `  Extracted ${files.length} video files from ZIP`,
                    "success"
                  );
                }
              }
            } else {
              // Save files separately (not merging, no overlay, or single file)
              const fileDate = parseSnapchatDate(metadata.date);
                for (const filename of files) {
                    let fileData = await innerZip.files[filename].async(
                      "arraybuffer"
                    );
                    const isOverlay = filename.toLowerCase().includes("overlay");
                    // Preserve original extension from the inner filename if present
                    let origExt = filename.includes('.') ? filename.substring(filename.lastIndexOf('.')) : null;
                    if (!origExt) {
                      const detected = detectFileExtension(new Uint8Array(fileData));
                      origExt = detected || extension;
                    }
                    const newFilename = isOverlay
                      ? `${fileNum}-overlay${origExt}`
                      : `${fileNum}-main${origExt}`;

                    // Add EXIF metadata to images
                    if (metadata.media_type === "Image") {
                      fileData = await addExifMetadata(
                        fileData,
                        metadata.date,
                        metadata.latitude,
                        metadata.longitude
                      );
                    }

                    zip.file(newFilename, fileData, { date: fileDate });
                    metadata.files.push({
                      path: newFilename,
                      size: fileData.byteLength,
                      type: isOverlay ? "overlay" : "main",
                    });
                  }
              addLog(`  Extracted ${files.length} files from ZIP`, "success");
            }
          } else {
            // Regular file
            let fileData = arrayBuffer;
            const filename = `${fileNum}${extension}`;
            const fileDate = parseSnapchatDate(metadata.date);

            // Add EXIF metadata to images
            if (metadata.media_type === "Image") {
              fileData = await addExifMetadata(
                fileData,
                metadata.date,
                metadata.latitude,
                metadata.longitude
              );
            }

            zip.file(filename, fileData, { date: fileDate });
            metadata.files.push({
              path: filename,
              size: arrayBuffer.byteLength,
              type: "single",
            });
            addLog(
              `  Downloaded: ${filename} (${formatBytes(
                arrayBuffer.byteLength
              )})`,
              "success"
            );
          }

        // Mark as successful
        metadata.status = "success";
        delete metadata.error; // Remove any previous error
      } catch (error) {
        addLog(`  ERROR: ${error.message}`, "error");
        metadata.status = "failed";
        metadata.error = error.message;
      }

      // Delays happen at the sub-batch level in processBatch, not per-item
    }

    function formatBytes(bytes) {
      if (bytes === 0) return "0 Bytes";
      const k = 1024;
      const sizes = ["Bytes", "KB", "MB", "GB"];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return (
        Math.round((bytes / Math.pow(k, i)) * 100) / 100 + " " + sizes[i]
      );
    }
  </script>
</body>

</html>